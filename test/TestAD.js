const chai = require('chai')
const expect = chai.expect
const AirDrop = artifacts.require("Airdrop")
const Token = artifacts.require("TestTokenA")
const { leavesWithProof, merkleRoot } = require("./generated")
const { start_time, end_time, root_changed_encode, root_changed_types } = require("./constants")
const { getEventLogs, takeSnapshot, revertToSnapShot, advanceTimeAndBlock, logLatestBlockTimestamp } = require("./utils")

let airDrop
let token
let snapShot
let snapshotId

contract("AirDrop", () => {
  beforeEach(async () => {
    airDrop = await AirDrop.deployed()
    token = await Token.deployed()
    snapShot = await takeSnapshot()
    snapshotId = snapShot['result']
  })

  afterEach(async () => {
    await revertToSnapShot(snapshotId)
  })

  describe('check()', async () => {
    it('should verify root successful with proof generated by typescript', async () => {
      await check(true)
    })

    it('should failure to verify root after set an unmatched root', async () => {
      const fakeRoot = '0xe4a6109e00d53b509bac49787d00c85d41ca682e297d029647c8c45db8f8c36f'
      await airDrop.set_root.sendTransaction(fakeRoot)
      const log = await getEventLogs(airDrop.address, root_changed_encode, root_changed_types)
      expect(log).to.have.property('previous').that.to.be.eq(merkleRoot)
      expect(log).to.have.property('now').that.to.be.eq(fakeRoot)
      await check(false)
      await airDrop.set_root.sendTransaction(merkleRoot)
      await check(true)
    })

    it('should not decrease the amount less than one day', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 9 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400)
      await check(true, 1)
    })

    it('should decrease the amount by 20% when one day after start_time', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 10 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 2)
      await check(true, 0.8)
    })

    it('should decrease the amount by 20% after one day after start_time', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 11 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 2).and.to.be.greaterThan(86400)
      await check(true, 0.8)
    })

    it('should decrease the amount by 40% after two days after start_time', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 21 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 3).and.to.be.greaterThan(86400 * 2)
      await check(true, 0.6)
    })

    it('should decrease the amount by 60% after three days after start_time', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 31 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 4).and.to.be.greaterThan(86400 * 3)
      await check(true, 0.4)
    })

    it('should decrease the amount by 80% after four days after start_time', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 41 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 5).and.to.be.greaterThan(86400 * 4)
      await check(true, 0.2)
    })

    it('should decrease the amount by 100% after five days after start_time', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 51 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 6).and.to.be.greaterThan(86400 * 5)
      await check(true, 0)
    })

    it('should decrease the amount by 100% after six days after start_time', async () => {
      const currentBlockTimestamp = await advanceTime(86400 * 61 / 10)
      expect(currentBlockTimestamp - start_time).to.be.lessThan(86400 * 7).and.to.be.greaterThan(86400 * 6)
      await check(true, 0)
    })

    async function advanceTime(time) {
      const latestBlockTimestamp = await logLatestBlockTimestamp()
      await advanceTimeAndBlock(time + (start_time - latestBlockTimestamp))
      return await logLatestBlockTimestamp()
    }

    async function check(isAvailable, shrinkRate = 1) {
      for (let i = 0; i < leavesWithProof.length; i++) {
        const leaf = leavesWithProof[i]
        const v = await airDrop.check.call(i + 2854, leaf.address, leaf.amount, leaf.proof)
        expect(v.available).to.be.eq(isAvailable)
        expect(v.start.toString()).to.be.eq(start_time.toString())
        expect(v.end.toString()).to.be.eq(end_time.toString())
        if (!isAvailable) {
          expect(v.claimable.toString()).to.be.eq('0')
        } else {
          expect(v.claimable.toString()).to.be.eq((Math.ceil(leaf.amount * shrinkRate)).toString())
        }
      }
    }
  })

  describe('claim()', async () => {
    it('should failure to claim when Not Started', async () => {

    })

    it('should failure to claim when Expired', async () => {

    })

    it('should failure to claim when Not Verified', async () => {

    })
  })
})
